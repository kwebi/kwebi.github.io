<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>算法 - 分类 - Kwebi's blog</title><link>https://kwebi.github.io/categories/%E7%AE%97%E6%B3%95/</link><description>算法 - 分类 - Kwebi's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 19 May 2024 22:21:09 +0800</lastBuildDate><atom:link href="https://kwebi.github.io/categories/%E7%AE%97%E6%B3%95/" rel="self" type="application/rss+xml"/><item><title>CodeForces 1163B2个人题解</title><link>https://kwebi.github.io/codeforces-1163b2%E4%B8%AA%E4%BA%BA%E9%A2%98%E8%A7%A3/</link><pubDate>Sun, 19 May 2024 22:21:09 +0800</pubDate><author>kwebi</author><guid>https://kwebi.github.io/codeforces-1163b2%E4%B8%AA%E4%BA%BA%E9%A2%98%E8%A7%A3/</guid><description>题目链接如下：CF-R-558-Div2 B2. Cat Party (Hard Edition) 题意： 在 $ n $ 天里，每一天都会有一只猫来到志郎家。在第 $ i$ 天来的猫有一条颜色为 $U_i$ 的丝带。志</description></item><item><title>gym101177I-最长上升子序列</title><link>https://kwebi.github.io/gym101177i-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</link><pubDate>Fri, 04 Oct 2019 21:31:35 +0000</pubDate><author>kwebi</author><guid>https://kwebi.github.io/gym101177i-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid><description>&lt;p>题目大意是给你一系列区间，区间两两互不相交，但可能会有重复出现，区间的值等于区间的长度，求最大的上升的区间值和。你可以类比最长上升子序列，不过最长上升子序列求的是序列的长度，而这里转化为序列的值。
&lt;/p></description></item><item><title>快速幂与模运算</title><link>https://kwebi.github.io/%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E6%A8%A1%E8%BF%90%E7%AE%97/</link><pubDate>Wed, 15 May 2019 17:21:41 +0000</pubDate><author>kwebi</author><guid>https://kwebi.github.io/%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E6%A8%A1%E8%BF%90%E7%AE%97/</guid><description><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1226" target="_blank" rel="noopener noreffer ">例题</a>:</p>
<blockquote>
<p>输入 <code>b</code>，<code>p</code>，<code>k</code> 的值，求 <code>b</code>^<code>p</code> mod <code>k</code> 的值。其中 <code>b</code>，<code>p</code>，<code>k</code> 为长整型数。</p>
</blockquote>]]></description></item><item><title>最小生成树算法</title><link>https://kwebi.github.io/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 04 May 2019 13:49:31 +0000</pubDate><author>kwebi</author><guid>https://kwebi.github.io/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/</guid><description>&lt;h3 id="1-prim算法">(1) Prim算法&lt;/h3>
&lt;p>取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在添加的顶点 w 和已经在生成树上的顶点v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n 个顶点为止。&lt;/p></description></item><item><title>优先队列的应用C++实现</title><link>https://kwebi.github.io/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8c-%E5%AE%9E%E7%8E%B0/</link><pubDate>Tue, 30 Oct 2018 22:53:04 +0000</pubDate><author>kwebi</author><guid>https://kwebi.github.io/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8c-%E5%AE%9E%E7%8E%B0/</guid><description>&lt;p>优先队列可以用堆来实现, 堆底层可以用数组表示，
通过索引关系，可以表示成一颗二叉完全树&lt;/p></description></item></channel></rss>
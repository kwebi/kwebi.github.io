[{"categories":[""],"content":"逆向超能犇的登录api 首先可以从网页端逆向js，不难推出其使用hex_hmac_md5算法对登录用户名和密码进行了加密。并抓包其登录api和切换网络优先级的api。 ","date":"2024-12-15","objectID":"/%E8%B6%85%E8%83%BD%E7%8A%87%E4%BF%A1%E5%8F%B7%E6%96%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E8%84%9A%E6%9C%AC/:1:0","tags":["网络","爬虫","Python"],"title":"超能犇信号断网自动切换脚本","uri":"/%E8%B6%85%E8%83%BD%E7%8A%87%E4%BF%A1%E5%8F%B7%E6%96%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E8%84%9A%E6%9C%AC/"},{"categories":[""],"content":"程序逻辑 运行逻辑如下：不断用ping命令监测是否断网，间隔几秒监测一次。 如果失败，判断是否在8-24点之间，如果是（则切换为仅sa，再测一次，如果断网切换4g） 如果不在8-24点，则切换为4g。 后续再监测一次，如果还是断网，则切换回自动，暂停10分钟 我的脚本跑在n1盒子上，和cpe用网线连接，用青龙面板定时运行。一般不会出现登录失败的情况。如果切换网络失败，进行重新登录又失败，则会暂停1小时。 ","date":"2024-12-15","objectID":"/%E8%B6%85%E8%83%BD%E7%8A%87%E4%BF%A1%E5%8F%B7%E6%96%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E8%84%9A%E6%9C%AC/:2:0","tags":["网络","爬虫","Python"],"title":"超能犇信号断网自动切换脚本","uri":"/%E8%B6%85%E8%83%BD%E7%8A%87%E4%BF%A1%E5%8F%B7%E6%96%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E8%84%9A%E6%9C%AC/"},{"categories":[""],"content":"脚本环境 需安装python程序和requests库。下载安装python后，手动执行: pip install requests 即可。 代码中的 username 改为自己的用户名, password 改为自己的密码, host 改为自己的路由器ip, 详细见代码注释。如何执行python代码自行百度。 import requests import json import datetime import time import os import hmac import hashlib # 需手动执行: pip install requests # pip install pyexecjs #双引号内改为自己的用户名 username = \"admin\" #双引号内改为自己的密码 password = \"admin\" #双引号内改为自己的路由器ip host = \"192.168.88.1\" headers = { \"Accept\": \"application/json, text/javascript, */*\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"zh-CN, zh\", \"Cache-Control\": \"no-cache\", \"Connection\": \"keep-alive\", \"Content-Type\": \"application/json\", \"Host\": \"192.168.88.1\", \"Origin\": \"http:// 192.168.88.1\", \"Pragma\": \"no-cache\", \"Referer\": \"http://192.168.88.1/html/settings.html\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0Win64x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.6261.95 Safari/537.36\", } s = requests.Session() s.headers.update(headers) key: str = \"0123456789\" # 测试网络连接 url = \"http://www.baidu.com\" url2 = \"qq.com\" def hex_hmac_md5(key, msg): \"\"\" 计算使用MD5散列算法的HMAC，并返回十六进制字符串形式的结果。 :param key: HMAC密钥 :param msg: 消息 :return: 十六进制HMAC值 \"\"\" hmac_digest = hmac.new(key.encode( 'utf-8'), msg.encode('utf-8'), hashlib.md5) return hmac_digest.hexdigest() username = hex_hmac_md5(key, username) password = hex_hmac_md5(key, password) def login(username: str, password: str) -\u003e bool: data = {'username': username, 'password': password} response = s.post(url=f\"http://{host}/goform/login\", headers=headers, data=json.dumps(data)) print(response.text) try: ret = json.loads(response.text) if(ret['retcode'] != 0): return False except Exception as e: return False return True def mnet_set_prefer_net_mode(type: int): if type == 0: data = r'{\"mnet_acqorder\":\"auto\",\"mnet_band\":\"auto\",\"mnet_scan_mode\":\"auto\"}' elif type == 1: data = r'{\"mnet_acqorder\":\"sa\",\"mnet_band\":\"auto\",\"mnet_scan_mode\":\"auto\"}' elif type == 2: data = r'{\"mnet_acqorder\":\"4g only\",\"mnet_band\":\"auto\",\"mnet_scan_mode\":\"auto\"}' response = s.post(url=f\"http://{host}/action/mnet_set_prefer_net_mode\", headers=headers, data=data) print(response.text) try: ret = json.loads(response.text) if(ret['retcode'] != 0): return False except Exception as e: #失败重新登录 is_login_sucess = login(username, password) if(is_login_sucess): print(\"登录成功\") response = s.post(url=f\"http://{host}/action/mnet_set_prefer_net_mode\", headers=headers, data=data) print(response.text) else: print(\"登录失败\") time.sleep(3600) def test_network(url=url, timeout=1): try: response = requests.get(url, timeout=timeout) if response.status_code == 200: return True else: return False except requests.exceptions.RequestException: return False def is_connected_to_internet(host=url2): \"\"\" 检查设备是否连接到互联网。 使用谷歌的DNS服务器进行ping测试。 \"\"\" if(os.name == \"nt\"): response = os.system(f\"ping {host}\") else: response = os.system(f\"ping -c 1 {host}\") if response == 0: return True else: return False def test()-\u003ebool: start_run_time = time.time() end_run_time = time.time()+3585 is_login_sucess = login(username, password) if(is_login_sucess): print(\"登录成功\") else: print(\"登录失败\") exec_cnt: int = 0 # 测试次数 flag: bool = False # 是否白天失败切换4g while True: #运行超过1小时，结束 if(time.time()\u003eend_run_time): break # 范围时间 start_time = datetime.datetime.strptime( str(datetime.datetime.now().date()) + '8:00', '%Y-%m-%d%H:%M') end_time = datetime.datetime.strptime( str(datetime.datetime.now().date()) + '23:59', '%Y-%m-%d%H:%M') # 当前时间 now_time = datetime.datetime.now() # 如果断网 if not is_connected_to_internet(): print(\"网络异常\") # 判断当前时间是否在范围时间内，切换仅5g if start_time \u003c now_time \u003c end_time: print(\"当前时间在范围时间内, 切换仅5g\") mnet_set_prefer_net_mode(1) time.sleep(5) # 网络测试失败,切换仅4g if is_connected_to_internet() == False: print(\"#网络测试失败,切换仅4g\") mnet_set_prefer_net_mode(2) flag = True exec_cnt = 0 time.sleep(5) if not is_connected_to_internet() and flag: print(\"4g网络异常, 恢复自动, 休息10分钟\") mnet_set_prefer_net_mode(0) time.sleep(600) else: #不在时间范围内, 直接切换4g print(\"不在时间范围内, 直接切换4g\") mnet_set_prefer_net_mode(2) time.sleep(5) flag = ","date":"2024-12-15","objectID":"/%E8%B6%85%E8%83%BD%E7%8A%87%E4%BF%A1%E5%8F%B7%E6%96%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E8%84%9A%E6%9C%AC/:3:0","tags":["网络","爬虫","Python"],"title":"超能犇信号断网自动切换脚本","uri":"/%E8%B6%85%E8%83%BD%E7%8A%87%E4%BF%A1%E5%8F%B7%E6%96%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E8%84%9A%E6%9C%AC/"},{"categories":["算法"],"content":"undered_map 加速 参考文章：Tricks to make unordered_map faster added。 undered_map 使用拉链法 hash，可以通过改变初始大小和负载因子来变快。可以变快约 1/5。 unordered_map\u003cint, int\u003e mp; mp.reserve(1024); mp.max_load_factor(0.25); ","date":"2024-05-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84hash%E4%BC%98%E5%8C%96/:0:1","tags":["hash"],"title":"算法竞赛中的hash优化","uri":"/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84hash%E4%BC%98%E5%8C%96/"},{"categories":["算法"],"content":"防 hack 参考文章：Blowing up unordered_map, and how to stop getting hacked on it。 在 cf 等比赛中可以 hack 别人的 unordered_map 代码，自定义 hash 函数可以防止针对默认 hash 造数据而超时。缺点是常数很大。也可能超时。 struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c x += 0x9e3779b97f4a7c15; x = (x ^ (x \u003e\u003e 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x \u003e\u003e 27)) * 0x94d049bb133111eb; return x ^ (x \u003e\u003e 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } }; unordered_map\u003cint, int,custom_hash\u003e mp; mp.reserve(1024); mp.max_load_factor(0.25); ","date":"2024-05-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84hash%E4%BC%98%E5%8C%96/:0:2","tags":["hash"],"title":"算法竞赛中的hash优化","uri":"/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84hash%E4%BC%98%E5%8C%96/"},{"categories":["算法"],"content":"用 gp_hash_table 变得更快 参考文章：浅谈 pb_ds 库及其在 OI/其他算竞中的应用 gp_hash_table 使用探测法，常数小，加入自定义 hash 后依然很快。综合最优。需要注意的是，此容器没有 count() 函数，我们只能用 find(x)!=end() 做查询是否存在。 #include \u003cbits/stdc++.h\u003e #include \u003cext/pb_ds/assoc_container.hpp\u003e #include \u003cext/pb_ds/hash_policy.hpp\u003e // #include \u003cbits/extc++.h\u003e //一般也可用这个 struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c x += 0x9e3779b97f4a7c15; x = (x ^ (x \u003e\u003e 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x \u003e\u003e 27)) * 0x94d049bb133111eb; return x ^ (x \u003e\u003e 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } }; __gnu_pbds::gp_hash_table\u003cint, int,custom_hash\u003e mp; ","date":"2024-05-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84hash%E4%BC%98%E5%8C%96/:0:3","tags":["hash"],"title":"算法竞赛中的hash优化","uri":"/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84hash%E4%BC%98%E5%8C%96/"},{"categories":[""],"content":"题目链接如下：C. Beautiful Triple Pairs，求最美三元组的对数（一对最美三元组指两个三元组，恰好有2个元素相同，一个不同）。 思路是分类讨论，$(a,b,c)$ ，分别计算 $(a,b)$, $(a,c)$ , $(b,c)$ 的最美三元组，最后相加。 因为需要有一个元素不同，需要去重，然后记录重复元组个数。然后计数即可，计数思路是分类计数，以 $[[1,1,2],[1,1,2],[1,1,3],[1,1,4],[1,1,4]]$ 为例子，答案是每类元组个数乘剩下元组个数的和，最后除以二。 AC代码如下： #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cmath.h\u003e #include \u003cqueue\u003e #include \u003cstdio.h\u003e #include \u003cvector\u003e #include \u003cstring.h\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003ccassert\u003e using namespace std; using ll = long long; typedef pair\u003cll, ll\u003e pll; constexpr int N = 200005; ll a[N]; struct Node { ll a, b, c; bool operator\u003c(const Node\u0026 x) const { if (a != x.a) { return a \u003c x.a; } else if (a == x.a) { if (b != x.b) { return b \u003c x.b; } else if (b == x.b) { return c \u003c x.c; } } } }; int main() { // cin.tie(nullptr)-\u003esync_with_stdio(false); int T; cin \u003e\u003e T; while (T-- \u003e 0) { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; } map\u003cNode, ll\u003e st; for (int i = 0; i + 2 \u003c n; i++) { st[ {a[i], a[i + 1], a[i + 2]}]++; } map\u003cpll, ll\u003e vp1; map\u003cpll, ll\u003e vp2; map\u003cpll, ll\u003e vp3; map\u003cpll, ll\u003e vpc1; map\u003cpll, ll\u003e vpc2; map\u003cpll, ll\u003e vpc3; for (auto val : st) { auto e = val.first; auto cnt = val.second; auto lp1 = make_pair(e.a, e.b); auto lp2 = make_pair(e.b, e.c); auto lp3 = make_pair(e.a, e.c); vp1[lp1]++; vpc1[lp1] += cnt; vp2[lp2]++; vpc2[lp2] += cnt; vp3[lp3]++; vpc3[lp3] += cnt; } ll ans = 0; for (auto val : st) { auto e = val.first; auto cnt = val.second; auto lp1 = make_pair(e.a, e.b); auto lp2 = make_pair(e.b, e.c); auto lp3 = make_pair(e.a, e.c); ll ad = cnt; ans += (cnt ) * (vpc1[lp1] - cnt ); ans += (cnt ) * (vpc2[lp2] - cnt ); ans += (cnt ) * (vpc3[lp3] - cnt ); } cout \u003c\u003c ans/2 \u003c\u003c '\\n'; } return 0; } ","date":"2024-05-21","objectID":"/codeforces-1974-c%E9%A2%98%E8%A7%A3/:0:0","tags":[""],"title":"CodeForces 1974 C题解","uri":"/codeforces-1974-c%E9%A2%98%E8%A7%A3/"},{"categories":["算法"],"content":"题目链接如下：CF-R-558-Div2 B2. Cat Party (Hard Edition) 题意： 在 $ n $ 天里，每一天都会有一只猫来到志郎家。在第 $ i$ 天来的猫有一条颜色为 $U_i$ 的丝带。志郎想知道最大的数字 $ x $ ，如果我们考虑前 $ x $ 天的连线，那么可以从这个连线中去掉$ 1 $天，这样在剩下的$x−1$天中出现的每种颜色的丝带出现的次数都是一样的。 转化为数学含义，在 $ n $ 个数的数组中，在前 $ x $ 中去掉一个，前 $x-1$ 个，每个数出现的次数都一样。 例如：$[2,2,1,1,5,4,4,5]$，那么，$x=7$ 构成了一个答案，因为如果我们去掉最左边的 $U_i = 5$ ，每种色带颜色在 $x−1$ 天的前缀中将正好出现两次。 思路： 记录每个数出现的次数，用map记录出现次数的组数，然后从右到左模拟判断。比如 $[2,2,1,1,5,4,4,5]$，2出现2次，1出现2次，5出现2次，4出现2次。那么出现次数都是2次，4组。 判断方法如下： 看出现次数的集合为1还是2，其他都无法满足要求 为1，两种情况，一种是所有数全部都一样，一种是所有数都不一样（出现次数都为1）满足要求。 为2，那么看出现次数的组数，是否存在一组次数，能全部转换为另一组次数。比如： $[2,2,1,1,5,4,4]$，2次的3组，1次的1组。去掉一次一组的即可，即某一组次数1，组数1。 $[2,2,1,1,1,4,4]$，2次的2组，3次的1组。把3次的去掉一次，那么刚好变成2次的3组。所以规律是需要一类次数比一另类次数多1，然后组数刚好为1。 如果条件不满足，那么需要更新两个map，即出现 $a_i$ 的次数的map1，次数的组数的map2，一个数删除了，对应数的次数也减少，如果数组完全没有这个数了，则删除。对应次数减少了，那么map2对应也要更新（移除一个数，一个数的次数的组数减少，另一个次数的组数可能增加）。 AC代码 #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cmath.h\u003e #include \u003cqueue\u003e #include \u003cstdio.h\u003e #include \u003cvector\u003e #include \u003cmath.h\u003e #include \u003cstring.h\u003e #include \u003cmap\u003e #include \u003cunordered_map\u003e #include \u003cassert.h\u003e using namespace std; using ll = long long; constexpr int N = 100005; int a[N]; unordered_map\u003cint, int\u003e b; int num[N]; unordered_map\u003cint, int\u003e mp; int main() { int n; cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; } for (int i = 1; i \u003c= n; i++) { mp[a[i]]++;//v的个数的集合 } for (auto e : mp) { b[e.second]++;//v有多少个的组数 } for (int i = n; i \u003e= 1; i--) { auto ib = b.begin(); ib++;//ib是b里面的第二个元素 auto ip = *(b.begin()); if (b.size() == 2 ) { auto is = *ib; if (ip.second == 1 \u0026\u0026 ip.first - 1 == is.first) {//刚好1组比2组多一个数 cout \u003c\u003c i; break; } if (is.second == 1 \u0026\u0026 is.first - 1 == ip.first) { cout \u003c\u003c i; break; } if (is.second == 1 \u0026\u0026 is.first == 1) { //2个组，有一个组内只有一个数 cout \u003c\u003c i; break; } if (ip.second == 1 \u0026\u0026 ip.first == 1) { cout \u003c\u003c i; break; } } if (b.size() == 1 ) { if (ip.first == 1) {//一个组一个数 cout \u003c\u003c i; break; } if (ip.first == i) {//一个组，数全相同 cout \u003c\u003c i; break; } } int v = a[i]; b[mp[v]]--;//v个数的组数减少 if (b[mp[v]] == 0) {//组数为0，删除 b.erase(mp[v]); } mp[v]--;//v的个数减少 if (mp[v] == 0) { mp.erase(v); } else { b[mp[v]]++;//减少后的个数对应的组数增加 } } return 0; } ","date":"2024-05-19","objectID":"/codeforces-1163b2%E4%B8%AA%E4%BA%BA%E9%A2%98%E8%A7%A3/:0:0","tags":["CodeForces"],"title":"CodeForces 1163B2个人题解","uri":"/codeforces-1163b2%E4%B8%AA%E4%BA%BA%E9%A2%98%E8%A7%A3/"},{"categories":null,"content":"题目链接如下：E - Alternating String 题目大意如下：一个由 0 和 1 组成的长度为 𝑁 的字符串，如果字符串中任意两个连续的字符都不相同，则称为良好字符串。进行以下操作 𝑄 次： 1是从 𝐿 到 𝑅 翻转字符串， 0 变 1 ， 1 变 0 。2是判断 𝐿 到 𝑅 是否为良好字符串。 $$ （1≤N,Q≤5×10^5) $$ 思路如下：Q为 5×10^5 ，那么总体复杂度不超过 𝑛𝑙𝑜𝑔𝑛 。可以看出规律，一个字符串是否为良好字符串，可以分为左右两个字符串，左边和右边必须都为良好字符串，并且两个字符串连接处必须不相同。可以看出具有结合律性质，用线段树进行解决。L到R翻转，不影响L到R是否为良好字符串，所以每次翻转，打上标记，然后将代表L..R区间的树节点的左右改变一下，如果是翻转打上标记的区间的子区间，那么需要下放懒标记，直到修改区间，再维护一下父节点状态。查询带有懒标记的一个子区间，也同样需要下放，再维护。 构造线段树： struct Node { short v = -1; // 值，good string为0，否则为1 short lv, rv; short lz = 0;//懒标记 }; void maintain(vector\u003cNode\u003e\u0026 tr, int o) { Node ln = tr[o * 2]; Node rn = tr[o * 2 + 1]; tr[o].lv = ln.lv; tr[o].rv = rn.rv; if (ln.v == 1 \u0026\u0026 rn.v == 1 \u0026\u0026 ln.rv != rn.lv) { // 维护信息,两个区间结合，判断是否为good string tr[o].v = 1; } else { tr[o].v = 0; } } void build(vector\u003cNode\u003e\u0026 tr, int l, int r, int o) { if (l == r) { tr[o].v = 1; tr[o].lv = a[l]; tr[o].rv = a[l]; return; } int mid = (l + r) / 2; build(tr, l, mid, o * 2); build(tr, mid + 1, r, o * 2 + 1); maintain(tr, o); } 翻转L到R： void revNode(Node\u0026 n) { n.lz ^= 1; n.lv ^= 1; n.rv ^= 1; } void lowdown(vector\u003cNode\u003e\u0026 tr, int o) // 下放懒标记 { tr[o].lz = 0; revNode(tr[o * 2]); revNode(tr[o * 2 + 1]); } void query1(vector\u003cNode\u003e\u0026 tr, int l, int r, int ql, int qr, int o) { if (ql == l \u0026\u0026 qr == r) { revNode(tr[o]); if (l == r) tr[o].lz = 0; return; } if (tr[o].lz == 1) { // 传递懒标记 lowdown(tr, o); } int mid = (l + r) / 2; if (qr \u003c= mid) { query1(tr, l, mid, ql, qr, o * 2); } if (ql \u003e mid) { query1(tr, mid + 1, r, ql, qr, o * 2 + 1); } if (ql \u003c= mid \u0026\u0026 qr \u003e mid) { query1(tr, l, mid, ql, mid, o * 2); query1(tr, mid + 1, r, mid + 1, qr, o * 2 + 1); } maintain(tr, o); } 查询L到R： Node query2(vector\u003cNode\u003e\u0026 tr, int l, int r, int ql, int qr, int o) { if (ql == l \u0026\u0026 qr == r) { return tr[o]; } int mid = (l + r) / 2; if (tr[o].lz == 1) { // 传递懒标记 lowdown(tr, o); } if (qr \u003c= mid) { Node ln = query2(tr, l, mid, ql, qr, o * 2); return ln; } if (ql \u003e mid) { Node rn = query2(tr, mid + 1, r, ql, qr, o * 2 + 1); return rn; } if (ql \u003c= mid \u0026\u0026 qr \u003e mid) { Node ln = query2(tr, l, mid, ql, mid, o * 2); Node rn = query2(tr, mid + 1, r, mid + 1, qr, o * 2 + 1); maintain(tr, o); Node res; res.lv = ln.lv; res.rv = rn.rv; if (ln.v == 1 \u0026\u0026 rn.v == 1 \u0026\u0026 ln.rv != rn.lv) { // 合并区间维护是否为好字符串信息 res.v = 1; } else { res.v = 0; } return res; } } 主函数如下： #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cmap\u003e #include \u003cmath.h\u003e #include \u003cqueue\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cvector\u003e using namespace std; using ll = long long; struct Node { short v = -1; // 值，good string为0，否则为1 short lv, rv; short lz = 0; }; vector\u003cshort\u003e a(500005); vector\u003cNode\u003e tr(2000005 + 1024); char s[500005]; int main() { int n, q; cin.tie(0)-\u003esync_with_stdio(false); cin \u003e\u003e n \u003e\u003e q; cin \u003e\u003e s; for (int i = 0; i \u003c strlen(s); i++) { a[i + 1] = s[i] - '0'; } build(tr, 1, n, 1); for (int i = 0; i \u003c q; i++) { int t, ql, qr; cin \u003e\u003e t \u003e\u003e ql \u003e\u003e qr; if (t == 1) { query1(tr, 1, n, ql, qr, 1); } if (t == 2) { int k = query2(tr, 1, n, ql, qr, 1).v; if (k == 1) cout \u003c\u003c \"Yes\" \u003c\u003c '\\n'; else cout \u003c\u003c \"No\" \u003c\u003c '\\n'; } } return 0; } 官方题解使用的是前后比较后得出的数组A，数组Ai表示的是 𝑆𝑖 是否等于 𝑆𝑖+1，每次翻转，影响的只有此数组的两边，所以线段树只需单点修改，无需带懒标记的区间修改。常数更小。查询L到R，只需判断L到R-1是否都为1即可，可以用区间和判断。 ","date":"2024-05-19","objectID":"/abc341_e/:0:0","tags":null,"title":"abc341_E","uri":"/abc341_e/"},{"categories":null,"content":"前言 之前一直使用 hexo+next 主题，但是遇到个问题就是每次换环境或者换电脑，需要重新安装 node，node_moudles，从新装主题，由于 npm 更新或者包源更换等原因，好久没用，现在失败，所以不想折腾 hexo 了，试一下简单的 hugo+LoveIt 主题。 ","date":"2024-05-19","objectID":"/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0hugo/:0:1","tags":null,"title":"迁移博客到hugo+LoveIt","uri":"/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0hugo/"},{"categories":null,"content":"过程 主要参考从零开始的 Hugo 博客搭建这个系列文章。 下载 从 Github 下载 Hugo 对应版本的（由于文件过多，所以可能要点 show all 才能看见）压缩包，注意要下载带扩展 extend 版本的，不然后续可能会报错。然后解压至 D:\\Programs\\bin。 配置系统路径： 打开开始菜单栏，搜索高级系统设置。 打开高级系统设置，点击环境变量，在下半部分的系统变量中找到 Path ，点击，点击新建。把路径 D:\\Programs\\bin 输进去，再确定即可。打开命令行，查看 Hugo 的版本，以判断上面步骤是否成功，代码如下： #查看hugo是否安装成功 hugo version 使用 # 终端中前往 D:\\Hblog 创建一个新的网站,新建blog文件夹，可换成自己想要的名字 hugo new site blog # 安装自己喜欢的主题（这里以 LoveIt 为例） ## Git 的下载这里不涉及，若有需求可以自行查找 ## 如果要用 vercel 的话，不要用 git ，直接 下载源码再放到 themes 目录下面就行，具体可见文章第二部分 cd blog git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt #若主题要更新 cd themes/LoveIt git pull # 回退到 D:\\Hblog\\blog设置 conf.toml 的 theme cd .. cd .. # 添加主题配置 echo theme = \"LoveIt\" \u003e\u003e config.toml 下载好主题后，themes/LoveIt 的 exampleSite 目录一般有一个 config.toml 配置文件，根据注释做一些基本的修改，再复制到你的根目录下的 config.tmol 文件。这里直接给出修改后的 config.toml 文件： baseURL = \"https://kwebi.github.io\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"Kwebi's blog\" defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true # 默认每页列表显示的文章数目 paginate = 12 # 谷歌分析代号 [UA-XXXXXXXX-X] googleAnalytics = \"\" # 版权描述，仅仅用于 SEO copyright = \"\" # 是否使用 robots.txt enableRobotsTXT = true # 是否使用 git 信息 #enableGitInfo = true # 是否使用 emoji 代码 enableEmoji = true # 忽略一些构建错误 ignoreErrors = [\"error-remote-getjson\", \"error-missing-instagram-accesstoken\"] # 作者配置 [author] name = \"kwebi\" email = \"\" # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) codeFences = true guessSyntax = true lineNos = true lineNumbersInTable = true # false 是必要的设置 # (https://github.com/dillonzq/LoveIt/issues/158) # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 noClasses = false # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # 是否在文档中直接使用 HTML 标签 unsafe = true # 目录设置 [markup.tableOfContents] startLevel = 2 endLevel = 6 [params] # 网站默认主题样式 [\"auto\", \"light\", \"dark\"] defaultTheme = \"light\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 #gitRepo = \"\" # LoveIt 新增 | 0.1.1 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # [\"sha256\", \"sha384\", \"sha512\", \"md5\"] fingerprint = \"sha256\" # LoveIt 新增 | 0.2.0 日期格式 dateFormat = \"2006-01-02\" # 网站标题, 用于 Open Graph 和 Twitter Cards title = \"Kwebi的博客\" # 网站描述, 用于 RSS, SEO, Open Graph 和 Twitter Cards description = \"Kwebi的博客\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"首页中间的图片\"] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 [\"fixed\", \"normal\", \"auto\"] desktopMode = \"normal\" # 移动端导航栏模式 [\"fixed\", \"normal\", \"auto\"] mobileMode = \"normal\" # LoveIt 新增 | 0.2.0 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Kwebi的博客\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # LoveIt 新增 | 0.2.5 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # LoveIt 新增 | 0.2.0 自定义内容 (支持 HTML 格式) custom = '' # LoveIt 新增 | 0.2.0 是否显示 Hugo 和主题信息 hugo = false # LoveIt 新增 | 0.2.0 是否显示版权信息 copyright = true # LoveIt 新增 | 0.2.0 是否显示作者 author = true # 网站创立年份 since = 2018 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = '' # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # LoveI","date":"2024-05-19","objectID":"/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0hugo/:0:2","tags":null,"title":"迁移博客到hugo+LoveIt","uri":"/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0hugo/"},{"categories":null,"content":"github action 添加 gh-pages.yml 文件 在 D:\\Hblog\\blog 下新建一个文件，名称为.github，然后在.github 夹下新建一个文件夹 workflows，再在 workflows 文件夹下新建一个文件叫 gh-pages.yml 在 gh-pages.yml 输入以下内容后保存。 把这次修改同步到 github name: Deploy Hugo Site to Github Pages on Master Branch on: push: branches: - main jobs: build-deploy: runs-on: ubuntu-latest #不要用旧的，不然会失败 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"0.76.0\" # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.BLOG_SECRET }} external_repository: kwebi/kwebi.github.io # remote branch publish_dir: \"./public\" # cname: blog.funnycode.org.cn keep_files: false # remove existing files publish_branch: main # deploying branch commit_message: ${{ github.event.head_commit.message }} publish_dir 指定发布的目录，./docs 指 blog 项目下的 docs 目录下的内容会被发布 publish_branch 发布到 kwebi.github.io 项目的 docs 分支 secrets.BLOG_SECRET 的 BLOG_SECRET 则是上面设置 Private Key 的变量名 git status git add . git commit -m \"new\" git push 成功后，找到刚刚的 Github 仓库，点击 Actions ，就可以看到我们的网站部署成功。 kwebi.github.io 配置 配置 Setting publish_dir 如果是\"./docs\" 相应的 gitpages Source 的目录也要更改 如果 github 上面仓库改名后，本地 git remote 也需对应更新 git remote -v #查看remote仓库有哪些 git remote set-url origin https://github.com/username/newname.git #origin可自定义 git push origin \u003cbranch name\u003e #可以是main或者master等 ","date":"2024-05-19","objectID":"/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0hugo/:0:3","tags":null,"title":"迁移博客到hugo+LoveIt","uri":"/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0hugo/"},{"categories":null,"content":"安装WSL 在cmd中输入以下命令： wsl --install 有疑问可看下面文章 如何使用 WSL 在 Windows 上安装 需要注意的点是系统版本不能太低。 如果中途显示访问失败可以考虑更换DNS和Host ","date":"2023-11-27","objectID":"/wsl%E8%A3%85%E9%9D%92%E9%BE%99/:1:0","tags":["wsl"],"title":"windows安装wsl和青龙面板","uri":"/wsl%E8%A3%85%E9%9D%92%E9%BE%99/"},{"categories":null,"content":"安装docker 下载docker desktop，安装中根据提示选择wsl方式，并根据下面文章设置： WSL 上的 Docker 容器入门 完成上面步骤后，可打开cmd，输入wsl，再输入docker，有内容则成功。 ","date":"2023-11-27","objectID":"/wsl%E8%A3%85%E9%9D%92%E9%BE%99/:2:0","tags":["wsl"],"title":"windows安装wsl和青龙面板","uri":"/wsl%E8%A3%85%E9%9D%92%E9%BE%99/"},{"categories":null,"content":"安装青龙 确保进入wsl里面，输入： wget -q https://yanyu.ltd/https://raw.githubusercontent.com/yanyuwangluo/VIP/main/Scripts/sh/ql.sh -O ql.sh \u0026\u0026 bash ql.sh 根据提示安装即可 进入后台后，安装依赖可看下面文章： 青龙面板-安装依赖 ","date":"2023-11-27","objectID":"/wsl%E8%A3%85%E9%9D%92%E9%BE%99/:3:0","tags":["wsl"],"title":"windows安装wsl和青龙面板","uri":"/wsl%E8%A3%85%E9%9D%92%E9%BE%99/"},{"categories":null,"content":"几年前稍微玩过Emacs,但没有深入，虽然现在也不算精通，不过起码还能融入日常使用，也算入门吧。 国内很多教程都是教怎么配置，怎么写Emacs Lisp，殊不知，这样反而会打击新人的积极性，毕竟很麻烦，很多人没有这个耐心一个个配。不如先拿一个现成的使用，后面的个性化配置等用熟后再学也不迟。 ","date":"2022-04-27","objectID":"/doom-emacs%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/:0:0","tags":["Emacs"],"title":"Doom Emacs初步使用","uri":"/doom-emacs%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"首先安装 国内已有很多教程，这里给出他们的链接，建议安装版本为27 21 天学会 Emacs（2022 Edition） Doom Emacs 的教程 Windows用户通过WSL2 安装Emacs ","date":"2022-04-27","objectID":"/doom-emacs%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/:1:0","tags":["Emacs"],"title":"Doom Emacs初步使用","uri":"/doom-emacs%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"代理 Doom Emacs安装方式一般是通过克隆github上的仓库来进行的，直接克隆将会非常慢而且容易失败，这里提供一些解决办法 以Windows中的WSL2为例，首先Windows系统上要挂上代理(SSR，V2Ray等等)，建议把Windows上的git也开启代理，在powershell上输入如下命令： # HTTP/HTTPS 协议，port 需与代理软件设置的一致 git config –-global http.proxy http://127.0.0.1:port # SOCKS5 协议 git config --global http.proxy socks5://127.0.0.1:port 对代理软件要允许它访问局域网。然后在WSL的终端的~目录下中 vim ~/.proxyrc # 输入如下内容后，键入Esc 和 : x保存 # 7890换成自己的代理软件端口 #!/bin/bash host_ip=$(cat /etc/resolv.conf |grep \"nameserver\" |cut -f 2 -d \" \") export ALL_PROXY=\"http://$host_ip:7890\" # 退出后在终端输入 source .proxyrc 当然也可以选择安装proxychains sudo apt-get install proxychains sudo nano /etc/proxychains.conf # 改为如下，ip和端口改为windows上的ip和代理的端口 socks5 127.0.0.1 8888 # 要运行时，在前面假释proxychains即可，如： proxychains curl -i google.com 然后就可以快速克隆 Doom Emacs的仓库了 git clone --depth 1 https://github.com/hlissner/doom-emacs ~/.emacs.d ~/.emacs.d/bin/doom install ","date":"2022-04-27","objectID":"/doom-emacs%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/:2:0","tags":["Emacs"],"title":"Doom Emacs初步使用","uri":"/doom-emacs%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"快捷键 执行完毕后即可键入emacs打开了，下面介绍一些基本操作，如果你会简单的Vim操作那么更简单，因为Doom Emacs天然支持Vim操作，按Ctr+Z可以进行切换 可供参考链接： https://noelwelsh.com/posts/doom-emacs/ 按键 意义 Spc+b 缓冲区操作 Spc+w 窗口操作 Spc+f 文件操作 Spc+: 等同于M+x,可输入指令 Spc+TAB workspace操作 Spc+h 帮助文档 Spc+s 搜索文件、缓冲区等 M+x eshell 打开终端 Spc+q 退出 这些只要你键入前两个，后面的选项会提示,相当方便。 vim相关操作不需要太多，懂等i,esc,v等相关操作和对应的模式即可。 以上，一个高配版vim就完成了 ","date":"2022-04-27","objectID":"/doom-emacs%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/:3:0","tags":["Emacs"],"title":"Doom Emacs初步使用","uri":"/doom-emacs%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"开启编程语言插件 进入~/.doom.d/init.el 把lsp 前面的注释去掉，并把下方对应的语言开启 以上即可进行快乐的玩耍使用了。 ","date":"2022-04-27","objectID":"/doom-emacs%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/:4:0","tags":["Emacs"],"title":"Doom Emacs初步使用","uri":"/doom-emacs%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"我购买的是阿里云的学生机，操作系统是CentOS 部署的项目是Nodejs和React的前后端分离项目，需要安装配置nodejs，mysql，nginx等 ","date":"2020-07-11","objectID":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:0:0","tags":["Linux"],"title":"在服务器上部署项目","uri":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"首先安装nvm 安装git yum install git -y 下载nvm git clone git://github.com/creationix/nvm.git ~/nvm 设置nvm到bash echo \"source ~/nvm/nvm.sh\" \u003e\u003e ~/.bashrc source ~/.bashrc 查询node版本 nvm list-remote 安装node.js nvm install v12.0.0 使用nodejs nvm use v12.0.0 ","date":"2020-07-11","objectID":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:1:0","tags":["Linux"],"title":"在服务器上部署项目","uri":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"安装nginx yum -y install nginx nginx相关操作 nginx -h #查看帮助 nginx -c filename #设置配置文件并启动nginx nginx -t #测试配置文件是否正确 ","date":"2020-07-11","objectID":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:2:0","tags":["Linux"],"title":"在服务器上部署项目","uri":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"安装mysql 下载mysql5.7 wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm 进行repo安装 rpm -ivh mysql57-community-release-el7-9.noarch.rpm 进入到 /etc/yum.repos.d/目录，执行 yum install mysql-server 启动mysql systemctl start mysqld systemctl restart mysqld # 重启mysql 获取临时密码 grep 'temporary password' /var/log/mysqld.log 登录mysql，输入刚刚获取到的临时密码 mysql -u root -p 设置密码强度要求 set global validate_password_policy=LOW; 更改密码 ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';#把123456替换为你自己的密码 ","date":"2020-07-11","objectID":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:3:0","tags":["Linux"],"title":"在服务器上部署项目","uri":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"设置mysql默认编码为utf8 sudo vim /etc/my.cnf 在[client]字段里加入default-character-set=utf8 在[mysql]字段里加入default-character-set=utf8 在[mysqld]字段里加入character-set-server=utf8 ","date":"2020-07-11","objectID":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:4:0","tags":["Linux"],"title":"在服务器上部署项目","uri":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"安装pm2 npm install -g pm2 pm2 常用命令 pm2 start app.js --name my-api # 命名进程 pm2 list # 显示所有进程状态 pm2 logs # 显示所有进程日志 pm2 stop all # 停止所有进程 pm2 restart all # 重启所有进程 pm2 stop 0 # 停止指定的进程 pm2 restart 0 # 重启指定的进程 pm2 delete 0 # 杀死指定的进程 ","date":"2020-07-11","objectID":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:5:0","tags":["Linux"],"title":"在服务器上部署项目","uri":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"部署项目到nginx，并使用nginx反向代理 把项目从github上clone下来，前端项目执行npm build后 可以在/etc/nginx/conf.d/目录下新建一个react-blog.conf，然后编辑这个文件 配置如下: server { listen 7890;#服务器内部使用的端口号 server_name 127.0.0.1;#(自己的服务器IP) root /home/user/code/koa-blog/react-blog/build/;#build后的目录 index index.html; } 然后打开/etc/nginx/nginx.conf这个文件 在server下再加上 server { listen 8078; server_name example.com; location / { proxy_pass http://localhost:8078; } } 要在服务器提供商的管理网页中开放8078端口。 由于使用80端口需要备案，所以可以先用其他端口代替 后端使用pm2进行运行，假设运行后端程序提供的端口为6543 那么该端口也可以通过nginx进行反向代理 server { listen 8078; server_name api.example.com; location / { proxy_pass http://localhost:6543; } } 所以对外部统一保留8078端口即可，可以根据不同的域名来访问不同的服务。 参考链接： mysql安装 mysql编码设置 pm2相关 ","date":"2020-07-11","objectID":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/:6:0","tags":["Linux"],"title":"在服务器上部署项目","uri":"/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"categories":["编程语言"],"content":"循环与闭包 在一次面试中，面试官出了这样一道题，让我说出运行结果 for(var i=1;i\u003c=5;i++){ setTimeout(()=\u003e{ console.log(i); },i*1000); } 这段代码在运行时会以每秒一次的频率输出五次 6。 首先，延迟函数的回调会在循环结束时才执行(具体内容可以了解一下事件循环)。根据作用域的工作原理，它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i，所有函数共享一个 i 的引用。 可以按照下面来改进： for (var i=1; i\u003c=5; i++) { (function(j) { setTimeout(()=\u003e{ console.log( j ); }, j*1000 ); })( i ); } //打印1到5 IIFE(立即调用函数表达式)会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的 作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 如果你知道ES6的let，特点是具有块作用域，for循环的let每次迭代都会用上一次迭代结束的值初始化这个变量，所以还可以这样写： for (let i=1; i\u003c=5; i++) { setTimeout(()=\u003e{ console.log( i ); }, i*1000 ); } //打印1到5 ","date":"2020-04-28","objectID":"/javascript%E4%B8%AD%E9%97%AD%E5%8C%85%E5%92%8Cthis%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:0:1","tags":["JavaScript"],"title":"JavaScript中闭包和this的一些理解","uri":"/javascript%E4%B8%AD%E9%97%AD%E5%8C%85%E5%92%8Cthis%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["编程语言"],"content":"普通匿名函数和箭头函数的this this 对象是在运行时基于函数的执行环境绑定的：在全局函数中，this 等于 window，而当函数被作为某个对象的方法调用时，this 等于那个对象。绑定this指向等问题这里不做讨论。 在匿名函数中使用 this 对象也可能会导致一些问题。匿名函数的执行环境具有全局性，其 this 对象通常指向 window，而在严格模式下则是undifined。 var name = \"The Window\"; var object = { name : \"My Object\", getNameFunc : function(){ return function(){ return this.name; }; } }; alert(object.getNameFunc()()); //\"The Window\"（在非严格模式下） 箭头函数的函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域 function foo() { setTimeout(() =\u003e { console.log('id:', this.id); }, 100); } var id = 21; foo.call({ id: 42 }); // id: 42 如果是普通函数，执行时this应该指向全局对象window，这时应该输出21 function foo() { setTimeout(function() { console.log('id:', this.id); }, 100); } var id = 21; foo.call({ id: 42 }); // id: 21 箭头函数的this就是外层作用域的this，所以它的this指向是相对固定化的。 ","date":"2020-04-28","objectID":"/javascript%E4%B8%AD%E9%97%AD%E5%8C%85%E5%92%8Cthis%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/:0:2","tags":["JavaScript"],"title":"JavaScript中闭包和this的一些理解","uri":"/javascript%E4%B8%AD%E9%97%AD%E5%8C%85%E5%92%8Cthis%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"},{"categories":["算法"],"content":"题目大意是给你一系列区间，区间两两互不相交，但可能会有重复出现，区间的值等于区间的长度，求最大的上升的区间值和。你可以类比最长上升子序列，不过最长上升子序列求的是序列的长度，而这里转化为序列的值。 input --- 5 1 1 10 11 5 7 3 4 10 11 --- output --- 6 比如这个样例6=((1-1+1)+(7-5+1)+(11-10+1))。 这里提供O(nlgn)的做法：因为区间互不相交，所以只需要考虑区间的一端，就可以确定区间的顺序,可以考虑构造这样一个结构体，l存左端点，v存区间长度，i存原区间的位置。 然后按左端点排序，由于区间会有重复，所以为了避免重复更新，需要先更新后面的，所以如果l相等，我们就把i大的放前面。排完序后：按照排的顺序更新，每次查询当前这个Node的i所能达到的最大序列值，然后在i位置更新为这个最大值加上自己的值。由于是按照区间的顺序更新，即前i个满足上升性质，所以可以保证前i个的最大值就是结点i所能达到的最大上升区间序列值。前i个的最大值用树状数组可以维护。 #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef pair\u003cint, int\u003e pii; struct Node { ll l, v; int i; bool operator==(const Node\u0026 b) const { return l == b.l; } bool operator\u003c(const Node\u0026 b) const { if (l == b.l) return i \u003e b.i; return l \u003c b.l; } }; Node a[100100]; ll Tr[100100]; ll INF = 2e9; int lowbit(int x) { return x \u0026 -x; } void update(int x, ll y, int n) { for (int i = x; i \u003c= n; i += lowbit(i)) { Tr[i] = max(Tr[i], y); } } ll query(int x) { ll ret = -INF; for (int i = x; i; i -= lowbit(i)) { ret = max(ret, Tr[i]); } return ret; } int main() { int n; scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { ll l, r; scanf(\"%lld%lld\", \u0026l, \u0026r); a[i].l = l; a[i].i = i; a[i].v = r - l + 1; } sort(a + 1, a + 1 + n); ll ans = 0; for (int i = 1; i \u003c= n; i++) { ll mx = query(a[i].i); update(a[i].i, mx + a[i].v, n); mx = query(a[i].i); ans = max(ans, mx); } printf(\"%lld\\n\", ans); return 0; } ","date":"2019-10-04","objectID":"/gym101177i-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/:0:0","tags":null,"title":"gym101177I-最长上升子序列","uri":"/gym101177i-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"categories":["算法"],"content":"例题: 输入 b，p，k 的值，求 b^p mod k 的值。其中 b，p，k 为长整型数。 快速幂 假设p=22，那么p可以用16+4+2表示，即 $2^4+2^2+2^1$ 表示 上代码(没求模)： using ll = long long; ll pow_mod(ll b, ll p) { ll res = 1; while (p \u003e 0) { if (p \u0026 1) { res = (res * b);//当前位为1，则乘以b } b = (b * b);//求下一位的b p \u003e\u003e= 1; } return res ; } 模运算 $$ (A+B) \\mod b=(A \\mod b+B \\mod b) \\mod b $$ $$ (A×B) \\mod b =((A \\mod b)×(B \\mod b)) \\mod b $$ 所以上面那题的可以写出来了 #include \u003cstdio.h\u003e using ll = long long; ll pow_mod(ll b, ll p, ll k) { ll res = 1; while (p \u003e 0) { if (p \u0026 1) { res = (res * b) % k; } b = (b * b) % k; p \u003e\u003e= 1; } return res % k; } int main() { ll b, p, k; scanf(\"%lld%lld%lld\", \u0026b, \u0026p, \u0026k); ll res = pow_mod(b, p, k); printf(\"%lld^%lld mod %lld=%lld\", b, p, k, res); return 0; } ","date":"2019-05-15","objectID":"/%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E6%A8%A1%E8%BF%90%E7%AE%97/:0:0","tags":null,"title":"快速幂与模运算","uri":"/%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E6%A8%A1%E8%BF%90%E7%AE%97/"},{"categories":["算法"],"content":"(1) Prim算法 取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在添加的顶点 w 和已经在生成树上的顶点v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n 个顶点为止。 该算法和Dijkstra算法有点类似，在生成树的构造过程中，图中 n 个顶点分属两个集合：已落在生成树上的顶点集 X 和尚未落在生成树上的顶点集V-X ，则应在所有连通X中顶点和V-X中顶点的边中选取权值最小的边。 ","date":"2019-05-04","objectID":"/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/:0:1","tags":null,"title":"最小生成树算法","uri":"/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"(二) 代码演示 #include\u003ccstring\u003e #include \u003calgorithm\u003e #include \u003cstdio.h\u003e #include \u003cvector\u003e using namespace std; const int INF = INT_MAX; const int MAX_V = 105;//最大顶点数，可以自己改 int cost[MAX_V][MAX_V]; //表示u,v之间的权值 int mincost[MAX_V]; //表示从集合x出发到每个顶点最小权值 bool used[MAX_V]; //表示顶点是否在集合x中 int V; //顶点数 int prim() { for (int i = 0; i \u003c V; i++) { mincost[i] = INF; used[i] = false; } mincost[0] = 0; int res = 0; while (true) { int v = -1; //从不属于集合x的顶点中选取从x到权值最小的顶点 for (int u = 0; u \u003c V; u++) { if (!used[u] \u0026\u0026 (v == -1 || mincost[u] \u003c mincost[v])) v = u; } if (v == -1) break; used[v] = true;//把顶点v加入集合x res += mincost[v];//把边的长度加到结果 for (int u = 0; u \u003c V; u++) { mincost[u] = min(mincost[u], cost[u][v]); } } return res; } ","date":"2019-05-04","objectID":"/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/:0:2","tags":null,"title":"最小生成树算法","uri":"/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"Kruskal算法 Kruskal算法相对更简单，按照边权值从小到大排序即可，依次添加，如果产生环，那么不添加该边，使用并查集即可判断。 ","date":"2019-05-04","objectID":"/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/:0:3","tags":null,"title":"最小生成树算法","uri":"/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/"},{"categories":["编程语言"],"content":"什么是右值？在C++中，一种被广泛认可的说法是，不能取地址，没有名字的就是右值，通常位于等号右边，相反，位于等号左边的，能取地址，有名字的被称为左值。 a = b + c 例如上式中，a就是个左值，b+c则是右值。 C++11又将右值分为纯右值和将亡值。纯右值包括：不跟对象关联的字面值，一些运算表达式(如1+3)。将亡值是跟右值引用相关的表达式，比如右值引用T\u0026\u0026函数的返回值，std::move的返回值。 右值引用就是对一个右值进行引用的类型。右值引用主要是为了移动语义，而移动语义则需要右值是可以被更改的，这也是为什么不用常量引用。只有绑定右值的引用类型，就能够延长右值的生命期。 std::move的功能是将左值强制转换为右值引用。 接下来看个例子： #include \u003ciostream\u003e using namespace std; class HugeMem { public: HugeMem(int size) : sz(size \u003e 0 ? size : 1) { c = new int[sz]; } ~HugeMem() { delete[] c; } HugeMem(HugeMem \u0026\u0026h) : sz(h.sz), c(h.c) { h.c = nullptr; } int sz; int *c; }; class Moveable { public: Moveable() : i(new int(3)), h(1024) {} ~Moveable() { delete i; } Moveable(Moveable \u0026\u0026m) : i(m.i), h(move(m.h)) { m.i = nullptr; } int *i; HugeMem h; }; 上述代码中，强制将m.h转化为右值，从而实现移动构造。对于一些简单的，不含任何资源的的类型来说，就无需实现移动语义了。有了移动语义，可以实现高性能的置换函数。 template \u003cclass T\u003e void swap(T \u0026a, T \u0026b) { T tmp(move(a)); a = move(b); b = move(tmp); } ","date":"2019-02-24","objectID":"/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/:0:0","tags":["C++"],"title":"右值引用与移动语义","uri":"/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"},{"categories":["日常"],"content":"如果要访问一些Google服务的话，拥有一个Google账号，将提供很多便利，但介于Google已经退出中国，所以拥有一个Google账户会有一些困难。 如果你要访问Google的某些服务的话，你可能需要做一些工作。 这里给一个hosts的资源，对应的去改就行。 https://github.com/googlehosts/hosts 接下来就是注册Google账号了，但是注册Google账号需要验证手机号，即使现在不验证，过一段时间以后也会要你验证的，不验证就不能使用。 手机QQ邮箱可以登录Google邮箱，也可以注册，不过注册到一半手机号无法验证，所以，手机QQ邮箱主要还是用来登陆。 前面讲的改hosts的步骤也主要是面向电脑端。 用电脑打开IE浏览器，注意不要用其他的，因为验证手机号时会出现问题。 然后输入: mail.google.com 接下来，更改左下角的语言，改为中文(香港)，接下来正常填写表格就能注册好了。 注册好后，用手机QQ邮箱登陆时也务必注意将语言改为中文(香港)，这样就没问题了。 ","date":"2018-11-29","objectID":"/%E6%B3%A8%E5%86%8C%E8%B0%B7%E6%AD%8C%E8%B4%A6%E5%8F%B7/:0:0","tags":["学习"],"title":"注册谷歌账号","uri":"/%E6%B3%A8%E5%86%8C%E8%B0%B7%E6%AD%8C%E8%B4%A6%E5%8F%B7/"},{"categories":["算法"],"content":"优先队列可以用堆来实现, 堆底层可以用数组表示， 通过索引关系，可以表示成一颗二叉完全树 C++的STL提供了相应的容器适配器 包含在queue头文件中 下面通过一道题来看如何使用它 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 string frequencySort(string s) { } 首先，统计字符出现的频率，通过map容器可以很简单的统计出来 map\u003cchar, int\u003e mp; for (auto e : s) { ++mp[e]; } 然后我们需要构建一个优先队列，而且要指定优先队列的排序方式 因此我们定义了一个自己的结构体, 并定义了\u003c操作符(降序定义小于号，升序大于号)， struct Node { Node(const pair\u003cchar, int\u003e \u0026val) : p(val) {} pair\u003cchar, int\u003e p; }; bool operator\u003c(const Node \u0026a, const Node \u0026b) { return a.p.second \u003c b.p.second; } 然后把键值对放入优先队列中 priority_queue\u003cNode, vector\u003cNode\u003e, less\u003cNode\u003e\u003e pq; for (auto e : mp) { pq.push(make_pair(e.first, e.second)); } 要用的时候，依次取出来就是了，每次取出的都是里面最大(或最小)的 string res; while (!pq.empty()) { for (int i = 0; i \u003c pq.top().p.second; ++i) res.push_back(pq.top().p.first); pq.pop(); } 还有好几个类似的题，都可以用这种方式解决 比如 : leetcode-692 leetcode-378 leetcode-373 leetcode-347 Python中也有相应的库提供类似的功能，《Python CookBook》中就有提到 \u003e\u003e\u003e import heapq \u003e\u003e\u003e nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2] \u003e\u003e\u003e print(heapq.nlargest(3, nums)) # Prints [42, 37, 23] \u003e\u003e\u003e print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2] 这些方法是基于堆数据结构实现的，对于查找的元素个数较少的时候比较合适 如果仅仅想查找最大或者最小（N=1）的元素的话，用min()或者max()比较合适 如果 N 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点 \u003e\u003e\u003e sorted(items)[:N] 下面是堆的实现, 还是建议掌握的 #include \u003cvector\u003e using namespace std; template \u003cclass T\u003e class Heap { public: Heap(size_t maxElems) { h = new HeapStruct; h-\u003eElems = new T[maxElems + 1]; h-\u003eCapacity = maxElems; h-\u003esize = 0; } ~Heap() { destroy(); } void insert(T x) { size_t i; if (isFull()) { return; } for (i = ++h-\u003esize; i / 2 \u003e 0 \u0026\u0026 h-\u003eElems[i / 2] \u003e x; i /= 2) { h-\u003eElems[i] = h-\u003eElems[i / 2]; } h-\u003eElems[i] = x; } T deleteMin() { size_t i, child; T minElems, lastElems; if (isEmpty()) return h-\u003eElems[0]; minElems = h-\u003eElems[1]; lastElems = h-\u003eElems[h-\u003esize--]; for (i = 1; i * 2 \u003c= h-\u003esize; i = child) { child = i * 2; if (child != h-\u003esize \u0026\u0026 h-\u003eElems[child + 1] \u003c h-\u003eElems[child]) ++child; if (lastElems \u003e h-\u003eElems[child]) h-\u003eElems[i] = h-\u003eElems[child]; else break; } h-\u003eElems[i] = lastElems; return minElems; } bool isFull() { return h-\u003esize == h-\u003eCapacity; } bool isEmpty() { return h-\u003esize == 0; } T findMin() { return h-\u003eElems[1]; } private: void destroy() { delete h-\u003eElems; delete h; } void makeEmpty() {} struct HeapStruct { size_t Capacity; size_t size; T *Elems; }; HeapStruct* h; }; ","date":"2018-10-30","objectID":"/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8c-%E5%AE%9E%E7%8E%B0/:0:0","tags":["C++"],"title":"优先队列的应用C++实现","uri":"/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8c-%E5%AE%9E%E7%8E%B0/"}]
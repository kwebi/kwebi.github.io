<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>prim算法</title>
    <url>/2019/05/04/2/</url>
    <content><![CDATA[<h3 id="1-普里姆算法的基本思想"><a href="#1-普里姆算法的基本思想" class="headerlink" title="(1) 普里姆算法的基本思想"></a>(1) 普里姆算法的基本思想</h3><p>取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在添加的顶点 w 和已经在生成树上的顶点v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n 个顶点为止。</p>
<a id="more"></a>

<p>在生成树的构造过程中，图中 n 个顶点分属两个集合：已落在生成树上的顶点集 X 和尚未落在生成树上的顶点集V-X ，则应在所有连通X中顶点和V-X中顶点的边中选取权值最小的边。</p>
<h3 id="二-代码演示"><a href="#二-代码演示" class="headerlink" title="(二) 代码演示"></a>(二) 代码演示</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V = <span class="number">105</span>;<span class="comment">//最大顶点数，可以自己改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cost[MAX_V][MAX_V]; <span class="comment">//表示u,v之间的权值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mincost[MAX_V]; <span class="comment">//表示从集合x出发到每个顶点最小权值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> used[MAX_V]; <span class="comment">//表示顶点是否在集合x中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V; <span class="comment">//顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mincost[i] = INF;</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mincost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//从不属于集合x的顶点中选取从x到权值最小的顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[u] &amp;&amp; (v == <span class="number">-1</span> || mincost[u] &lt; mincost[v]))</span><br><span class="line">                v = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        used[v] = <span class="literal">true</span>;<span class="comment">//把顶点v加入集合x</span></span><br><span class="line">        res += mincost[v];<span class="comment">//把边的长度加到结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++)</span><br><span class="line">        &#123;</span><br><span class="line">            mincost[u] = min(mincost[u], cost[u][v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>gym101177I 最长上升子序列</title>
    <url>/2019/10/04/1/</url>
    <content><![CDATA[<p>题目大意是给你一系列区间，区间两两互不相交，但可能会有重复出现，区间的值等于区间的长度，求最大的上升的区间值和。你可以类比最长上升子序列，不过最长上升子序列求的是序列的长度，而这里转化为序列的值。</p>
<a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">input</span><br><span class="line">---</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">10</span> <span class="number">11</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">10</span> <span class="number">11</span></span><br><span class="line">---</span><br><span class="line">output</span><br><span class="line">---</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>比如这个样例6=((1-1+1)+(7-5+1)+(11-10+1))。</p>
<p>这里提供<code>O(nlgn)</code>的做法：因为区间互不相交，所以只需要考虑区间的一端，就可以确定区间的顺序,可以考虑构造这样一个结构体，<code>l</code>存左端点，<code>v</code>存区间长度，<code>i</code>存原区间的位置。</p>
<p>然后按左端点排序，由于区间会有重复，所以为了避免重复更新，需要先更新后面的，所以如果<code>l</code>相等，我们就把<code>i</code>大的放前面。排完序后：按照排的顺序更新，每次查询当前这个Node的<code>i</code>所能达到的最大序列值，然后在<code>i</code>位置更新为这个最大值加上自己的值。由于是按照区间的顺序更新，即前<code>i</code>个满足上升性质，所以可以保证前<code>i</code>个的最大值就是结点i所能达到的最大上升区间序列值。前<code>i</code>个的最大值用树状数组可以维护。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ll l, v;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Node&amp; b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l == b.l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == b.l)</span><br><span class="line">            <span class="keyword">return</span> i &gt; b.i;</span><br><span class="line">        <span class="keyword">return</span> l &lt; b.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node a[<span class="number">100100</span>];</span><br><span class="line">ll Tr[<span class="number">100100</span>];</span><br><span class="line">ll INF = <span class="number">2e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, ll y, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;</span><br><span class="line">        Tr[i] = max(Tr[i], y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i)) &#123;</span><br><span class="line">        ret = max(ret, Tr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ll l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;l, &amp;r);</span><br><span class="line">        a[i].l = l;</span><br><span class="line">        a[i].i = i;</span><br><span class="line">        a[i].v = r - l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ll mx = query(a[i].i);</span><br><span class="line">        update(a[i].i, mx + a[i].v, n);</span><br><span class="line">        mx = query(a[i].i);</span><br><span class="line">        ans = max(ans, mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>右值引用与移动语义</title>
    <url>/2019/02/24/4/</url>
    <content><![CDATA[<p>什么是右值？在C++中，一种被广泛认可的说法是，不能取地址，没有名字的就是右值，通常位于等号右边，相反，位于等号左边的，能取地址，有名字的被称为左值。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; b + c</span><br></pre></td></tr></table></figure>

<p>例如上式中，a就是个左值，b+c则是右值。</p>
<p>C++11又将右值分为纯右值和将亡值。纯右值包括：不跟对象关联的字面值，一些运算表达式(如1+3)。将亡值是跟右值引用相关的表达式，比如右值引用<code>T&amp;&amp;</code>函数的返回值，<code>std::move</code>的返回值。</p>
<p>右值引用就是对一个右值进行引用的类型。右值引用主要是为了移动语义，而移动语义则需要右值是可以被更改的，这也是为什么不用常量引用。只有绑定右值的引用类型，就能够延长右值的生命期。</p>
<p><code>std::move</code>的功能是将左值强制转换为右值引用。</p>
<p>接下来看个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HugeMem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    HugeMem(<span class="keyword">int</span> size) : sz(size &gt; <span class="number">0</span> ? size : <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">    &#125;</span><br><span class="line">    ~HugeMem() &#123; <span class="keyword">delete</span>[] c; &#125;</span><br><span class="line">    HugeMem(HugeMem &amp;&amp;h) : sz(h.sz), c(h.c)</span><br><span class="line">    &#123;</span><br><span class="line">        h.c = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="keyword">int</span> *c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Moveable() : i(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>)), h(<span class="number">1024</span>) &#123;&#125;</span><br><span class="line">    ~Moveable() &#123; <span class="keyword">delete</span> i; &#125;</span><br><span class="line">    Moveable(Moveable &amp;&amp;m) : i(m.i), h(move(m.h))</span><br><span class="line">    &#123;</span><br><span class="line">        m.i = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *i;</span><br><span class="line">    HugeMem h;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码中，强制将m.h转化为右值，从而实现移动构造。对于一些简单的，不含任何资源的的类型来说，就无需实现移动语义了。有了移动语义，可以实现高性能的置换函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swap</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> &amp;<span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(move(a))</span></span>;</span><br><span class="line">    a = move(b);</span><br><span class="line">    b = move(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂与模运算</title>
    <url>/2019/05/15/5/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1226" target="_blank" rel="noopener">例题</a>:</p>
<blockquote>
<p>输入 <code>b</code>，<code>p</code>，<code>k</code> 的值，求 <code>b</code>^<code>p</code> mod <code>k</code> 的值。其中 <code>b</code>，<code>p</code>，<code>k</code> 为长整型数。</p>
</blockquote>
<a id="more"></a>

<ol>
<li>快速幂</li>
</ol>
<p>假设<code>p</code>=<code>22</code>，那么<code>p</code>可以用<code>16</code>+<code>4</code>+<code>2</code>表示，即 $2^4+2^2+2^1$ 表示<br><br /><br>上代码(没求模)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll b, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res * b);<span class="comment">//当前位为1，则乘以b</span></span><br><span class="line">        &#125;</span><br><span class="line">        b = (b * b);<span class="comment">//求下一位的b</span></span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>模运算</li>
</ol>
<p>$$<br>(A+B) \mod b=(A \mod b+B \mod b) \mod b<br>$$</p>
<p>$$<br>(A×B) \mod b =((A \mod b)×(B \mod b)) \mod b<br>$$</p>
<p>所以上面那题的可以写出来了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll b, ll p, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res * b) % k;</span><br><span class="line">        &#125;</span><br><span class="line">        b = (b * b) % k;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll b, p, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;b, &amp;p, &amp;k);</span><br><span class="line">    ll res = pow_mod(b, p, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld^%lld mod %lld=%lld"</span>, b, p, k, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>注册谷歌账号</title>
    <url>/2018/11/29/6/</url>
    <content><![CDATA[<p>如果要访问一些Google服务的话，拥有一个Google账号，将提供很多便利，但介于Google已经退出中国，所以拥有一个Google账户会有一些困难。</p>
<p>如果你要访问Google的某些服务的话，你可能需要做一些工作。</p>
<p>这里给一个hosts的资源，对应的去改就行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;googlehosts&#x2F;hosts</span><br></pre></td></tr></table></figure>

<p>接下来就是注册Google账号了，但是注册Google账号需要验证手机号，即使现在不验证，过一段时间以后也会要你验证的，不验证就不能使用。</p>
<p>手机QQ邮箱可以登录Google邮箱，也可以注册，不过注册到一半手机号无法验证，所以，手机QQ邮箱主要还是用来登陆。</p>
<p>前面讲的改hosts的步骤也主要是面向电脑端。</p>
<p>用电脑打开<code>IE浏览器</code>，注意不要用其他的，因为验证手机号时会出现问题。</p>
<p>然后输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mail.google.com</span><br></pre></td></tr></table></figure>

<p>接下来，更改左下角的语言，改为<code>中文(香港)</code>，接下来正常填写表格就能注册好了。</p>
<p>注册好后，用手机QQ邮箱登陆时也务必注意将语言改为<code>中文(香港)</code>，这样就没问题了。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>优先队列的应用 C++实现</title>
    <url>/2018/10/30/3/</url>
    <content><![CDATA[<p>优先队列可以用堆来实现, 堆底层可以用数组表示，<br>通过索引关系，可以表示成一颗二叉完全树</p>
<a id="more"></a>

<p>C++的STL提供了相应的容器适配器<br>包含在<code>queue</code>头文件中</p>
<p>下面通过一道题来看如何使用它</p>
<h4 id="给定一个字符串，请将字符串里的字符按照出现的频率降序排列。"><a href="#给定一个字符串，请将字符串里的字符按照出现的频率降序排列。" class="headerlink" title="给定一个字符串，请将字符串里的字符按照出现的频率降序排列。"></a><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/description/" target="_blank" rel="noopener">给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">frequencySort</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，统计字符出现的频率，通过map容器可以很简单的统计出来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : s)</span><br><span class="line">&#123;</span><br><span class="line">    ++mp[e];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们需要构建一个优先队列，而且要指定优先队列的排序方式<br>因此我们定义了一个自己的结构体, 并定义了<code>&lt;</code>操作符(降序定义小于号，升序大于号)，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Node(<span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;val) : p(val) &#123;&#125;</span><br><span class="line">    pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.p.second &lt; b.p.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后把键值对放入优先队列中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;Node, <span class="built_in">vector</span>&lt;Node&gt;, less&lt;Node&gt;&gt; pq;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : mp)</span><br><span class="line">&#123;</span><br><span class="line">    pq.push(make_pair(e.first, e.second));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要用的时候，依次取出来就是了，每次取出的都是里面最大(或最小)的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> res;</span><br><span class="line"><span class="keyword">while</span> (!pq.empty())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pq.top().p.second; ++i)</span><br><span class="line">        res.push_back(pq.top().p.first);</span><br><span class="line">    pq.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有好几个类似的题，都可以用这种方式解决</p>
<p>比如 :</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/top-k-frequent-words" target="_blank" rel="noopener">leetcode-692</a></li>
<li><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix" target="_blank" rel="noopener">leetcode-378</a></li>
<li><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums" target="_blank" rel="noopener">leetcode-373</a></li>
<li><a href="https://leetcode-cn.com/problems/top-k-frequent-elements" target="_blank" rel="noopener">leetcode-347</a></li>
</ul>
<p>Python中也有相应的库提供类似的功能，<code>《Python CookBook》</code>中就有提到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">-4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(heapq.nlargest(<span class="number">3</span>, nums)) <span class="comment"># Prints [42, 37, 23]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(heapq.nsmallest(<span class="number">3</span>, nums)) <span class="comment"># Prints [-4, 1, 2]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>这些方法是基于堆数据结构实现的，对于查找的元素个数较少的时候比较合适</p>
</li>
<li><p>如果仅仅想查找最大或者最小（N=1）的元素的话，用min()或者max()比较合适</p>
</li>
<li><p>如果 N 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点</p>
</li>
</ul>
<p><code>&gt;&gt;&gt; sorted(items)[:N]</code></p>
<h4 id="下面是堆的实现-还是建议掌握的"><a href="#下面是堆的实现-还是建议掌握的" class="headerlink" title="下面是堆的实现, 还是建议掌握的"></a>下面是堆的实现, 还是建议掌握的</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Heap(<span class="keyword">size_t</span> maxElems)</span><br><span class="line">    &#123;</span><br><span class="line">        h = <span class="keyword">new</span> HeapStruct;</span><br><span class="line">        h-&gt;Elems = <span class="keyword">new</span> T[maxElems + <span class="number">1</span>];</span><br><span class="line">        h-&gt;Capacity = maxElems;</span><br><span class="line">        h-&gt;size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Heap()</span><br><span class="line">    &#123;</span><br><span class="line">        destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> i;</span><br><span class="line">        <span class="keyword">if</span> (isFull())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = ++h-&gt;size; i / <span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; h-&gt;Elems[i / <span class="number">2</span>] &gt; x; i /= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            h-&gt;Elems[i] = h-&gt;Elems[i / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        h-&gt;Elems[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">deleteMin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> i, child;</span><br><span class="line">        T minElems, lastElems;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">return</span> h-&gt;Elems[<span class="number">0</span>];</span><br><span class="line">        minElems = h-&gt;Elems[<span class="number">1</span>];</span><br><span class="line">        lastElems = h-&gt;Elems[h-&gt;size--];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= h-&gt;size; i = child)</span><br><span class="line">        &#123;</span><br><span class="line">            child = i * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (child != h-&gt;size &amp;&amp; h-&gt;Elems[child + <span class="number">1</span>] &lt; h-&gt;Elems[child])</span><br><span class="line">                ++child;</span><br><span class="line">            <span class="keyword">if</span> (lastElems &gt; h-&gt;Elems[child])</span><br><span class="line">                h-&gt;Elems[i] = h-&gt;Elems[child];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        h-&gt;Elems[i] = lastElems;</span><br><span class="line">        <span class="keyword">return</span> minElems;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h-&gt;size == h-&gt;Capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h-&gt;size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">findMin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h-&gt;Elems[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> h-&gt;Elems;</span><br><span class="line">        <span class="keyword">delete</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeEmpty</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">size_t</span> Capacity;</span><br><span class="line">        <span class="keyword">size_t</span> size;</span><br><span class="line">        T *Elems;</span><br><span class="line">    &#125;;</span><br><span class="line">    HeapStruct* h;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中闭包和this的一些理解</title>
    <url>/2020/04/28/js-this/</url>
    <content><![CDATA[<h3 id="循环与闭包"><a href="#循环与闭包" class="headerlink" title="循环与闭包"></a>循环与闭包</h3><p>在一次面试中，面试官出了这样一道题，让我说出运行结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>这段代码在运行时会以每秒一次的频率输出五次 6。</p>
<p>首先，延迟函数的回调会在循环结束时才执行(具体内容可以了解一下事件循环)。根据作用域的工作原理，它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 <code>i</code>，所有函数共享一个 <code>i</code> 的引用。</p>
<p>可以按照下面来改进：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log( j );</span><br><span class="line">		&#125;, j*<span class="number">1000</span> );</span><br><span class="line">	&#125;)( i );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印1到5</span></span><br></pre></td></tr></table></figure>

<p><code>IIFE</code>(立即调用函数表达式)会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的 作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</p>
<p>如果你知道ES6的<code>let</code>，特点是具有块作用域，<code>for</code>循环的<code>let</code>每次迭代都会用上一次迭代结束的值初始化这个变量，所以还可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( i );</span><br><span class="line">	&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印1到5</span></span><br></pre></td></tr></table></figure>

<h3 id="普通匿名函数和箭头函数的this"><a href="#普通匿名函数和箭头函数的this" class="headerlink" title="普通匿名函数和箭头函数的this"></a>普通匿名函数和箭头函数的<code>this</code></h3><p><code>this</code> 对象是在运行时基于函数的执行环境绑定的：在全局函数中，<code>this</code> 等于 <code>window</code>，而当函数被作为某个对象的方法调用时，<code>this</code> 等于那个对象。绑定<code>this</code>指向等问题这里不做讨论。</p>
<p>在匿名函数中使用 <code>this</code> 对象也可能会导致一些问题。匿名函数的执行环境具有全局性，其<code>this</code> 对象通常指向<code>window</code>，而在严格模式下则是<code>undifined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	name : <span class="string">"My Object"</span>,</span><br><span class="line">	getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">		&#125;;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//"The Window"（在非严格模式下）</span></span><br></pre></td></tr></table></figure>

<p>箭头函数的函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数可以让<code>setTimeout</code>里面的<code>this</code>，绑定定义时所在的作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure>

<p>如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 21</span></span><br></pre></td></tr></table></figure>

<p>箭头函数的<code>this</code>就是外层作用域的<code>this</code>，所以它的<code>this</code>指向是相对固定化的。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>在服务器上部署项目</title>
    <url>/2020/07/11/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>我购买的是阿里云的学生机，操作系统是CentOS<br>部署的项目是Nodejs和React的前后端分离项目，需要安装配置nodejs，mysql，nginx等</p>
<a id="more"></a>

<h2 id="首先安装nvm"><a href="#首先安装nvm" class="headerlink" title="首先安装nvm"></a>首先安装nvm</h2><p>安装git</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install git -y</span><br></pre></td></tr></table></figure>

<p>下载nvm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/creationix/nvm.git ~/nvm</span><br></pre></td></tr></table></figure>

<p>设置nvm到bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"source ~/nvm/nvm.sh"</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>查询node版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm list-remote</span><br></pre></td></tr></table></figure>
<p>安装node.js</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install v12.0.0</span><br></pre></td></tr></table></figure>
<p>使用nodejs</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm use v12.0.0</span><br></pre></td></tr></table></figure>

<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install nginx</span><br></pre></td></tr></table></figure>
<p>nginx相关操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -h    <span class="comment">#查看帮助</span></span><br><span class="line">nginx -c filename  <span class="comment">#设置配置文件并启动nginx</span></span><br><span class="line">nginx -t    <span class="comment">#测试配置文件是否正确</span></span><br></pre></td></tr></table></figure>

<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>下载mysql5.7</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>进行repo安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>进入到 /etc/yum.repos.d/目录，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure>

<p>启动mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line">systemctl restart mysqld <span class="comment"># 重启mysql</span></span><br></pre></td></tr></table></figure>

<p>获取临时密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">'temporary password'</span> /var/<span class="built_in">log</span>/mysqld.log</span><br></pre></td></tr></table></figure>

<p>登录mysql，输入刚刚获取到的临时密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>设置密码强度要求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> global validate_password_policy=LOW;</span><br></pre></td></tr></table></figure>

<p>更改密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'123456'</span>;<span class="comment">#把123456替换为你自己的密码</span></span><br></pre></td></tr></table></figure>

<h2 id="设置mysql默认编码为utf8"><a href="#设置mysql默认编码为utf8" class="headerlink" title="设置mysql默认编码为utf8"></a>设置mysql默认编码为utf8</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/my.cnf</span><br></pre></td></tr></table></figure>
<ol>
<li>在[client]字段里加入default-character-set=utf8 </li>
<li>在[mysql]字段里加入default-character-set=utf8</li>
<li>在[mysqld]字段里加入character-set-server=utf8</li>
</ol>
<h2 id="安装pm2"><a href="#安装pm2" class="headerlink" title="安装pm2"></a>安装pm2</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure>
<p>pm2 常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start app.js --name my-api <span class="comment"># 命名进程</span></span><br><span class="line">pm2 list               <span class="comment"># 显示所有进程状态</span></span><br><span class="line">pm2 logs               <span class="comment">#  显示所有进程日志</span></span><br><span class="line">pm2 stop all           <span class="comment"># 停止所有进程</span></span><br><span class="line">pm2 restart all        <span class="comment"># 重启所有进程</span></span><br><span class="line">pm2 stop 0             <span class="comment"># 停止指定的进程</span></span><br><span class="line">pm2 restart 0          <span class="comment"># 重启指定的进程</span></span><br><span class="line">pm2 delete 0           <span class="comment"># 杀死指定的进程</span></span><br></pre></td></tr></table></figure>



<h2 id="部署项目到nginx，并使用nginx反向代理"><a href="#部署项目到nginx，并使用nginx反向代理" class="headerlink" title="部署项目到nginx，并使用nginx反向代理"></a>部署项目到nginx，并使用nginx反向代理</h2><p>把项目从github上clone下来，前端项目执行<code>npm build</code>后<br>可以在<code>/etc/nginx/conf.d/</code>目录下新建一个react-blog.conf，然后编辑这个文件<br>配置如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      7890;#服务器内部使用的端口号</span><br><span class="line">    server_name 127.0.0.1;#(自己的服务器IP)</span><br><span class="line"></span><br><span class="line">    root    &#x2F;home&#x2F;user&#x2F;code&#x2F;koa-blog&#x2F;react-blog&#x2F;build&#x2F;;#build后的目录</span><br><span class="line">    index   index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后打开<code>/etc/nginx/nginx.conf</code>这个文件<br>在server下再加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8078;</span><br><span class="line">    server_name example.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:8078;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要在服务器提供商的管理网页中开放8078端口。<br>由于使用80端口需要备案，所以可以先用其他端口代替</p>
<p>后端使用pm2进行运行，假设运行后端程序提供的端口为6543<br>那么该端口也可以通过nginx进行反向代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8078;</span><br><span class="line">    server_name api.example.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:6543;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以对外部统一保留8078端口即可，可以根据不同的域名来访问不同的服务。</p>
<p>参考链接：<br><a href="https://blog.csdn.net/wohiusdashi/article/details/89358071" target="_blank" rel="noopener">mysql安装</a><br><a href="https://www.cnblogs.com/roujiamo/p/10824511.html" target="_blank" rel="noopener">mysql编码设置</a><br><a href="https://www.cnblogs.com/i6010/articles/10857543.html" target="_blank" rel="noopener">pm2相关</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
